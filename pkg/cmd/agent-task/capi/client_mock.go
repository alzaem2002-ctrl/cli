// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package capi

import (
	"context"
	"sync"
)

// Ensure, that CapiClientMock does implement CapiClient.
// If this is not the case, regenerate this file with moq.
var _ CapiClient = &CapiClientMock{}

// CapiClientMock is a mock implementation of CapiClient.
//
//	func TestSomethingThatUsesCapiClient(t *testing.T) {
//
//		// make and configure a mocked CapiClient
//		mockedCapiClient := &CapiClientMock{
//			CreateJobFunc: func(ctx context.Context, owner string, repo string, problemStatement string, baseBranch string) (*Job, error) {
//				panic("mock out the CreateJob method")
//			},
//			GetJobFunc: func(ctx context.Context, owner string, repo string, jobID string) (*Job, error) {
//				panic("mock out the GetJob method")
//			},
//			ListSessionsForRepoFunc: func(ctx context.Context, owner string, repo string, limit int) ([]*Session, error) {
//				panic("mock out the ListSessionsForRepo method")
//			},
//			ListSessionsForViewerFunc: func(ctx context.Context, limit int) ([]*Session, error) {
//				panic("mock out the ListSessionsForViewer method")
//			},
//		}
//
//		// use mockedCapiClient in code that requires CapiClient
//		// and then make assertions.
//
//	}
type CapiClientMock struct {
	// CreateJobFunc mocks the CreateJob method.
	CreateJobFunc func(ctx context.Context, owner string, repo string, problemStatement string, baseBranch string) (*Job, error)

	// GetJobFunc mocks the GetJob method.
	GetJobFunc func(ctx context.Context, owner string, repo string, jobID string) (*Job, error)

	// ListSessionsForRepoFunc mocks the ListSessionsForRepo method.
	ListSessionsForRepoFunc func(ctx context.Context, owner string, repo string, limit int) ([]*Session, error)

	// ListSessionsForViewerFunc mocks the ListSessionsForViewer method.
	ListSessionsForViewerFunc func(ctx context.Context, limit int) ([]*Session, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateJob holds details about calls to the CreateJob method.
		CreateJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Owner is the owner argument value.
			Owner string
			// Repo is the repo argument value.
			Repo string
			// ProblemStatement is the problemStatement argument value.
			ProblemStatement string
			// BaseBranch is the baseBranch argument value.
			BaseBranch string
		}
		// GetJob holds details about calls to the GetJob method.
		GetJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Owner is the owner argument value.
			Owner string
			// Repo is the repo argument value.
			Repo string
			// JobID is the jobID argument value.
			JobID string
		}
		// ListSessionsForRepo holds details about calls to the ListSessionsForRepo method.
		ListSessionsForRepo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Owner is the owner argument value.
			Owner string
			// Repo is the repo argument value.
			Repo string
			// Limit is the limit argument value.
			Limit int
		}
		// ListSessionsForViewer holds details about calls to the ListSessionsForViewer method.
		ListSessionsForViewer []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Limit is the limit argument value.
			Limit int
		}
	}
	lockCreateJob             sync.RWMutex
	lockGetJob                sync.RWMutex
	lockListSessionsForRepo   sync.RWMutex
	lockListSessionsForViewer sync.RWMutex
}

// CreateJob calls CreateJobFunc.
func (mock *CapiClientMock) CreateJob(ctx context.Context, owner string, repo string, problemStatement string, baseBranch string) (*Job, error) {
	if mock.CreateJobFunc == nil {
		panic("CapiClientMock.CreateJobFunc: method is nil but CapiClient.CreateJob was just called")
	}
	callInfo := struct {
		Ctx              context.Context
		Owner            string
		Repo             string
		ProblemStatement string
		BaseBranch       string
	}{
		Ctx:              ctx,
		Owner:            owner,
		Repo:             repo,
		ProblemStatement: problemStatement,
		BaseBranch:       baseBranch,
	}
	mock.lockCreateJob.Lock()
	mock.calls.CreateJob = append(mock.calls.CreateJob, callInfo)
	mock.lockCreateJob.Unlock()
	return mock.CreateJobFunc(ctx, owner, repo, problemStatement, baseBranch)
}

// CreateJobCalls gets all the calls that were made to CreateJob.
// Check the length with:
//
//	len(mockedCapiClient.CreateJobCalls())
func (mock *CapiClientMock) CreateJobCalls() []struct {
	Ctx              context.Context
	Owner            string
	Repo             string
	ProblemStatement string
	BaseBranch       string
} {
	var calls []struct {
		Ctx              context.Context
		Owner            string
		Repo             string
		ProblemStatement string
		BaseBranch       string
	}
	mock.lockCreateJob.RLock()
	calls = mock.calls.CreateJob
	mock.lockCreateJob.RUnlock()
	return calls
}

// GetJob calls GetJobFunc.
func (mock *CapiClientMock) GetJob(ctx context.Context, owner string, repo string, jobID string) (*Job, error) {
	if mock.GetJobFunc == nil {
		panic("CapiClientMock.GetJobFunc: method is nil but CapiClient.GetJob was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Owner string
		Repo  string
		JobID string
	}{
		Ctx:   ctx,
		Owner: owner,
		Repo:  repo,
		JobID: jobID,
	}
	mock.lockGetJob.Lock()
	mock.calls.GetJob = append(mock.calls.GetJob, callInfo)
	mock.lockGetJob.Unlock()
	return mock.GetJobFunc(ctx, owner, repo, jobID)
}

// GetJobCalls gets all the calls that were made to GetJob.
// Check the length with:
//
//	len(mockedCapiClient.GetJobCalls())
func (mock *CapiClientMock) GetJobCalls() []struct {
	Ctx   context.Context
	Owner string
	Repo  string
	JobID string
} {
	var calls []struct {
		Ctx   context.Context
		Owner string
		Repo  string
		JobID string
	}
	mock.lockGetJob.RLock()
	calls = mock.calls.GetJob
	mock.lockGetJob.RUnlock()
	return calls
}

// ListSessionsForRepo calls ListSessionsForRepoFunc.
func (mock *CapiClientMock) ListSessionsForRepo(ctx context.Context, owner string, repo string, limit int) ([]*Session, error) {
	if mock.ListSessionsForRepoFunc == nil {
		panic("CapiClientMock.ListSessionsForRepoFunc: method is nil but CapiClient.ListSessionsForRepo was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Owner string
		Repo  string
		Limit int
	}{
		Ctx:   ctx,
		Owner: owner,
		Repo:  repo,
		Limit: limit,
	}
	mock.lockListSessionsForRepo.Lock()
	mock.calls.ListSessionsForRepo = append(mock.calls.ListSessionsForRepo, callInfo)
	mock.lockListSessionsForRepo.Unlock()
	return mock.ListSessionsForRepoFunc(ctx, owner, repo, limit)
}

// ListSessionsForRepoCalls gets all the calls that were made to ListSessionsForRepo.
// Check the length with:
//
//	len(mockedCapiClient.ListSessionsForRepoCalls())
func (mock *CapiClientMock) ListSessionsForRepoCalls() []struct {
	Ctx   context.Context
	Owner string
	Repo  string
	Limit int
} {
	var calls []struct {
		Ctx   context.Context
		Owner string
		Repo  string
		Limit int
	}
	mock.lockListSessionsForRepo.RLock()
	calls = mock.calls.ListSessionsForRepo
	mock.lockListSessionsForRepo.RUnlock()
	return calls
}

// ListSessionsForViewer calls ListSessionsForViewerFunc.
func (mock *CapiClientMock) ListSessionsForViewer(ctx context.Context, limit int) ([]*Session, error) {
	if mock.ListSessionsForViewerFunc == nil {
		panic("CapiClientMock.ListSessionsForViewerFunc: method is nil but CapiClient.ListSessionsForViewer was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Limit int
	}{
		Ctx:   ctx,
		Limit: limit,
	}
	mock.lockListSessionsForViewer.Lock()
	mock.calls.ListSessionsForViewer = append(mock.calls.ListSessionsForViewer, callInfo)
	mock.lockListSessionsForViewer.Unlock()
	return mock.ListSessionsForViewerFunc(ctx, limit)
}

// ListSessionsForViewerCalls gets all the calls that were made to ListSessionsForViewer.
// Check the length with:
//
//	len(mockedCapiClient.ListSessionsForViewerCalls())
func (mock *CapiClientMock) ListSessionsForViewerCalls() []struct {
	Ctx   context.Context
	Limit int
} {
	var calls []struct {
		Ctx   context.Context
		Limit int
	}
	mock.lockListSessionsForViewer.RLock()
	calls = mock.calls.ListSessionsForViewer
	mock.lockListSessionsForViewer.RUnlock()
	return calls
}
